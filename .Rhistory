a <- 11:24
a
dim(a) <- c(3, 2, 1, 2)
dim(a) <- c(1, 1, 7, 2)
a
dim(a) <- c( 1, 7, 2)
a
a <- 11:26
dim(a) <- c( 2, 2, 4)
a
dim(a) <- c( 2, 2, 2, 2)
a
dim(a) <- c( 2, 4, 2)
a
dim(a)
lenght(a)
length(a)
row(a)
nrow(a)
ncol(a)
is_positive <- is_positive+1
source("~/Documents/Magistrale/Statistical Lab/R Projects/hw1.R")
# extract from num_vec only the positive elements
is_positive <- is_positive+1
is_positive <- is_positive+1
is_positive <- is_positive+1
is_positive <- is_positive+1
is_positive <- is_positive+1
is_positive <- is_positive+1
is_positive <- is_positive+1
source("~/Documents/Magistrale/Statistical Lab/R Projects/hw1.R")
# get the class of num_vec
class(num_vec)
# get the class of num_vec
class(num_vec)
# get the class of num_vec
class(num_vec)
# get the class of num_vec
class(num_vec)
# get the class of num_vec
class(num_vec)
# get the class of num_vec
class(num_vec)
# This folder contains this file "hw1.R",
# and a subfolder /data, containing the file "serie_A_2019_2020.csv".
# Before you start, in the file manager (panel "Files" of RStudio),
# set this folder as working directory
# Basics ------------------------------------------------------------------
# Print the first ten integer numbers by just typing 1:10
# and running this line of code
1:10
# Calculate the sum of the first ten integer numbers
sum(1:10)
# Get the square of each of the first ten integer numbers
# use parenthesis in order to avoid mistakes!
(1:10) ^ 2
# Instead of repeating 1:10 each time, assign this to a vector of integer,
# let us call it int_vec
int_vec <- 1:10
# get the class of int_vec
class(int_vec)
# Calculate the sum of squares of int_vec
sum(int_vec^2)
# create the numeric vector num_vec running this code line
num_vec <- c(5, 2, 3.5, - 4, - 1)
# print num_vec
num_vec
# get the class of num_vec
class(num_vec)
# extract the first element of num_vec
num_vec[1]
# count the number of elements of num_vec
length(num_vec)
# extract the last element of num_vec
num_vec[length(num_vec)]
# extract the first and 4th element of num_vec
# (be careful! num_vec[1, 4] gives error!)
num_vec[c(1, 4)]
# extract only elements of num_vec in odd (dispari) position
num_vec[seq(from = 1, to = length(num_vec), by = 2)]
# calculate the minimum value
min(num_vec)
# calculate the maximum value
max(num_vec)
# calculate the sample mean
mean(num_vec)
# calculate the sum of all vector elements
sum(num_vec)
# create a logical vector that, for each element of num_vec is
# - TRUE if the element is greater or equal than 0
# - FALSE if the element is less than 0
log_var <- as.logical(num_vec/abs(num_vec))
class(log_var)
# assign this logical vector to a variable named is_positive
is_positive <- log_var
# get the class of is_positive
class(is_positive)
# extract from num_vec only the positive elements
is_positive <- is_positive+1
log_var <- as.logical(num_vec/abs(num_vec))
num_vec/abs(num_vec
)
as.logical(num_vec/abs(num_vec))
as.logical(num_vec/abs(num_vec) + 1)
num_vec/abs(num_vec) + 1
?as.logical
# This folder contains this file "hw1.R",
# and a subfolder /data, containing the file "serie_A_2019_2020.csv".
# Before you start, in the file manager (panel "Files" of RStudio),
# set this folder as working directory
# Basics ------------------------------------------------------------------
# Print the first ten integer numbers by just typing 1:10
# and running this line of code
1:10
# Calculate the sum of the first ten integer numbers
sum(1:10)
# Get the square of each of the first ten integer numbers
# use parenthesis in order to avoid mistakes!
(1:10) ^ 2
# Instead of repeating 1:10 each time, assign this to a vector of integer,
# let us call it int_vec
int_vec <- 1:10
# get the class of int_vec
class(int_vec)
# Calculate the sum of squares of int_vec
sum(int_vec^2)
# create the numeric vector num_vec running this code line
num_vec <- c(5, 2, 3.5, - 4, - 1)
# print num_vec
num_vec
# get the class of num_vec
class(num_vec)
# extract the first element of num_vec
num_vec[1]
# count the number of elements of num_vec
length(num_vec)
# extract the last element of num_vec
num_vec[length(num_vec)]
# extract the first and 4th element of num_vec
# (be careful! num_vec[1, 4] gives error!)
num_vec[c(1, 4)]
# extract only elements of num_vec in odd (dispari) position
num_vec[seq(from = 1, to = length(num_vec), by = 2)]
# calculate the minimum value
min(num_vec)
# calculate the maximum value
max(num_vec)
# calculate the sample mean
mean(num_vec)
# calculate the sum of all vector elements
sum(num_vec)
# create a logical vector that, for each element of num_vec is
# - TRUE if the element is greater or equal than 0
# - FALSE if the element is less than 0
log_var <- as.logical(num_vec/abs(num_vec) + 1)
class(log_var)
# assign this logical vector to a variable named is_positive
is_positive <- log_var
# extract from num_vec only the positive elements
is_positive <- is_positive+1
# get the class of is_positive
class(is_positive)
# create a logical vector that, for each element of num_vec is
# - TRUE if the element is greater or equal than 0
# - FALSE if the element is less than 0
log_var <- as.logical(num_vec/abs(num_vec) + 1)
# assign this logical vector to a variable named is_positive
is_positive <- log_var
# extract from num_vec only the positive elements
is_positive <- is_positive+1
# get the class of is_positive
class(is_positive)
# assign this logical vector to a variable named is_positive
is_positive <- log_var
class(is_positive)
# extract from num_vec only the positive elements
as.vector(is_positive)
as.vector(is_positive)
as.vector(is_positive)
as.vector(is_positive)
as.vector(is_positive)
as.vector(is_positive)
as.vector(is_positive)
as.double(is_positive)
is_positive <- num_vec*is_positive
# extract from num_vec only the positive elements
as.double(is_positive)
# This folder contains this file "hw1.R",
# and a subfolder /data, containing the file "serie_A_2019_2020.csv".
# Before you start, in the file manager (panel "Files" of RStudio),
# set this folder as working directory
# Basics ------------------------------------------------------------------
# Print the first ten integer numbers by just typing 1:10
# and running this line of code
1:10
# Calculate the sum of the first ten integer numbers
sum(1:10)
# Get the square of each of the first ten integer numbers
# use parenthesis in order to avoid mistakes!
(1:10) ^ 2
# Instead of repeating 1:10 each time, assign this to a vector of integer,
# let us call it int_vec
int_vec <- 1:10
# get the class of int_vec
class(int_vec)
# Calculate the sum of squares of int_vec
sum(int_vec^2)
# create the numeric vector num_vec running this code line
num_vec <- c(5, 2, 3.5, - 4, - 1)
# print num_vec
num_vec
# get the class of num_vec
class(num_vec)
# extract the first element of num_vec
num_vec[1]
# count the number of elements of num_vec
length(num_vec)
# extract the last element of num_vec
num_vec[length(num_vec)]
# extract the first and 4th element of num_vec
# (be careful! num_vec[1, 4] gives error!)
num_vec[c(1, 4)]
# extract only elements of num_vec in odd (dispari) position
num_vec[seq(from = 1, to = length(num_vec), by = 2)]
# calculate the minimum value
min(num_vec)
# calculate the maximum value
max(num_vec)
# calculate the sample mean
mean(num_vec)
# calculate the sum of all vector elements
sum(num_vec)
# create a logical vector that, for each element of num_vec is
# - TRUE if the element is greater or equal than 0
# - FALSE if the element is less than 0
log_var <- as.logical(num_vec/abs(num_vec) + 1)
class(log_var)
# assign this logical vector to a variable named is_positive
is_positive <- log_var
# get the class of is_positive
class(is_positive)
# extract from num_vec only the positive elements
as.double(is_positive)
is_positive <- num_vec*is_positive
mean(is_positive)
# sum only the positive elements of num_vec
sum(is_positive)
?plot
plot(num_vec)
set.seed(0)
?set.seed
long_vec <- rnorm(1000)
plot(long_vec)
mean(long_vec)
?summary
summary(long_vec)
# which is the median value of long_vec?
mean(long_vec)
log_var <- as.logical(num_vec/abs(num_vec) + 1)
class(log_var)
# assign this logical vector to a variable named is_positive
is_positive <- log_var
# get the class of is_positive
class(is_positive)
# extract from num_vec only the positive elements
as.double(is_positive)
is_positive <- num_vec[is_positive]
a <- c(3, 2, 1, 4)
a > 2
a <- c(3, 2, 1, 4)
mi =  a > 2
a <- c(3, 2, 1, 4)
mi <-   a > 2
which(a >= 2)
as.logical(c(1, 3, 1, 0, -1))
as.logical(c(1, 3, 1, -2, -1))
as.logical(c(1, 3, 1, 0, 0))
which(a >= 2)
a >= 2
a[a >= 2]
a[which(a >= 2)]
# create a logical vector that, for each element of num_vec is
# - TRUE if the element is greater or equal than 0
# - FALSE if the element is less than 0
log_var <- num_vec >= 0
class(log_var)
# create a logical vector that, for each element of num_vec is
# - TRUE if the element is greater or equal than 0
# - FALSE if the element is less than 0
log_var <- num_vec >= 0
class(log_var)
log_var
num_vec(is_positive)
num_vec[is_positive]
?new
setwd("~/Documents/Magistrale/Statistical Lab/Hitachi_train_batteries")
library(tidyverse)
library(ggplot2)
load("my_workspace.RData")
ggplot(subC2[1:2190,], aes(x = Timestamp, y = HMI_IBatt_C2)) +
geom_line(color = "black") +
#geom_line(mapping = aes(x = Timestamp, y = HMI_IBatt_C2), color = "black") +
facet_wrap(~Gruppo, scales = "fixed") +
labs(title = "Intensità C2 per Gruppo", x = "Date", y = "Ampere (I)")
voltaggio <- ggplot(subC2[1:2190,], aes(x = Timestamp, y = HMI_VBatt_C2)) +
geom_line(color = "black") +
geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "red") +
facet_wrap(~Gruppo, scales = "fixed") +
labs(title = "Intensità C2 per Gruppo", x = "Date", y = "Ampere (I)")
voltaggio
voltaggio <- ggplot(subC2[1:2190,], aes(x = Timestamp, y = HMI_VBatt_C2)) +
geom_line(color = "black") +
#geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "red") +
facet_wrap(~Gruppo, scales = "fixed") +
labs(title = "Intensità C2 per Gruppo", x = "Date", y = "Ampere (I)")
voltaggio
ggsave("Intensità_per_gruppo.png", intensità)
intensità <- ggplot(subC2[1:2190,], aes(x = Timestamp, y = HMI_IBatt_C2)) +
geom_line(color = "black") +
#geom_line(mapping = aes(x = Timestamp, y = HMI_IBatt_C2), color = "black") +
facet_wrap(~Gruppo, scales = "fixed") +
labs(title = "Intensità C2 per Gruppo", x = "Date", y = "Ampere (I)")
voltaggio <- ggplot(subC2[1:2190,], aes(x = Timestamp, y = HMI_VBatt_C2)) +
geom_line(color = "black") +
#geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "red") +
facet_wrap(~Gruppo, scales = "fixed") +
labs(title = "Intensità C2 per Gruppo", x = "Date", y = "Ampere (I)")
ggsave("Intensità_per_gruppo.png", intensità)
ggsave("Voltaggio_per_gruppo.png", voltaggio)
ggplot(data = subC2[1:5000,]) +
geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "black") +
labs(title = "Primi 5000 dati", x = "Date", y = "Voltage")
Voltage <- ggplot(data = subC2[1:5000,]) +
geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "black") +
labs(title = "Primi 5000 dati", x = "Date", y = "Voltage")
ggsave("Voltaggio.png", voltage)
Voltage <- ggplot(data = subC2[1:5000,]) +
geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "black") +
labs(title = "Primi 5000 dati", x = "Date", y = "Voltage")
voltage <- ggplot(data = subC2[1:5000,]) +
geom_line(mapping = aes(x = Timestamp, y = HMI_VBatt_C2), color = "black") +
labs(title = "Primi 5000 dati", x = "Date", y = "Voltage")
ggsave("Voltaggio.png", voltage)
View(subC2)
